1. Questions. Fields of interest
- title
- body
- link
- tags
- is_answered
- accepted_answer_id
- question_id
2. Answers. Fields
- title
- body



"Here is a piece of C++ code that shows some very peculiar behavior.
For some reason, sorting the data (before the timed region) miraculously makes the primary loop almost six times faster:
#include algorithm
#include ctime
#include iostream

int main()
{
 // Generate data
 const unsigned arraySize = 32768;
 int data[arraySize];

 for (unsigned c = 0; c arraySize; ++c)
 data[c] = std::rand() % 256;

 // !!! With this, the next loop runs faster.
 std::sort(data, data + arraySize);

 // Test
 clock_t start = clock();
 long long sum = 0;
 for (unsigned i = 0; i 100000; ++i)
 {
 for (unsigned c = 0; c arraySize; ++c)
 { // Primary loop.
 if (data[c] = 128)
 sum += data[c];
 }
 }

 double elapsedTime = static_castdouble(clock()-start) / CLOCKS_PER_SEC;

 std::cout elapsedTime '\
';
 std::cout sum = sum '\
';
}


Without std::sort(data, data + arraySize);, the code runs in 11.54 seconds.
With the sorted data, the code runs in 1.93 seconds.

(Sorting itself takes more time than this one pass over the array, so it's not actually worth doing if we needed to calculate this for an unknown array.)

Initially, I thought this might be just a language or compiler anomaly, so I tried Java:
import java.util.Arrays;
import java.util.Random;

public class Main
{
 public static void main(String[] args)
 {
 // Generate data
 int arraySize = 32768;
 int data[] = new int[arraySize];

 Random rnd = new Random(0);
 for (int c = 0; c arraySize; ++c)
 data[c] = rnd.nextInt() % 256;

 // !!! With this, the next loop runs faster
 Arrays.sort(data);

 // Test
 long start = System.nanoTime();
 long sum = 0;
 for (int i = 0; i 100000; ++i)
 {
 for (int c = 0; c arraySize; ++c)
 { // Primary loop.
 if (data[c] = 128)
 sum += data[c];
 }
 }

 System.out.println((System.nanoTime() - start) / 1000000000.0);
 System.out.println(sum = + sum);
 }
}

With a similar but less extreme result.

My first thought was that sorting brings the data into the cache, but that's silly because the array was just generated.

What is going on?
Why is processing a sorted array faster than processing an unsorted array?

The code is summing up some independent terms, so the order should not matter.

Related / follow-up QAs about the same effect with different/later compilers and options:

Why is processing an unsorted array the same speed as processing a sorted array with modern x86-64 clang?
gcc optimization flag -O3 makes code slower than -O2

